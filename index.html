<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Happy Birthday Gallery</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        :root {
            --primary: #f8f9fa;
            --accent: #ff4d6d;
            --glass: rgba(255, 255, 255, 0.1);
            --font-main: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: var(--font-main);
            touch-action: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        /* Loading Screen */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            transition: opacity 1s ease;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--glass);
            border-top: 3px solid var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* Birthday Overlay */
        #birthday-modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            text-align: center;
            padding: 20px;
        }

        .modal-content {
            background: var(--glass);
            padding: 40px;
            border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            max-width: 400px;
            backdrop-filter: blur(10px);
        }

        h1 { color: var(--accent); font-size: 2.5rem; margin-bottom: 10px; }
        p { color: white; margin-bottom: 25px; line-height: 1.6; }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 15px 35px;
            font-size: 1.1rem;
            border-radius: 30px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            font-weight: 600;
        }

        button:active { transform: scale(0.95); }

        /* Controls Tutorial */
        #controls-tutorial {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(10px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 998;
            text-align: center;
            padding: 20px;
            color: white;
        }

        .tutorial-content {
            background: rgba(255,255,255,0.05);
            padding: 40px;
            border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 600px;
            width: 90%;
        }

        .control-item {
            display: flex;
            align-items: center;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            border-left: 4px solid var(--accent);
        }

        .control-icon {
            width: 60px;
            height: 60px;
            background: rgba(255,77,109,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 20px;
            font-size: 24px;
        }

        .control-text {
            text-align: left;
            flex: 1;
        }

        .control-text h3 {
            margin: 0 0 5px 0;
            color: var(--accent);
        }

        .control-text p {
            margin: 0;
            color: rgba(255,255,255,0.8);
            font-size: 0.9rem;
        }

        /* UI Controls */
        #joystick-container {
            position: fixed;
            bottom: 40px;
            left: 40px;
            width: 100px;
            height: 100px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            display: none;
            touch-action: none;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: var(--accent);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 12px rgba(255,77,109,0.3);
        }

        #look-touch-area {
            position: fixed;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            display: none;
            z-index: 99;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 0.8rem;
            pointer-events: none;
            text-align: center;
            z-index: 101;
            background: rgba(0,0,0,0.3);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }

        /* Performance Monitor (Optional - can remove) */
        #perf-monitor {
            position: fixed;
            top: 10px;
            right: 10px;
            color: rgba(255,255,255,0.3);
            font-size: 0.7rem;
            font-family: monospace;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p style="margin-top: 20px;">Setting up the gallery...</p>
    </div>

    <div id="birthday-modal">
        <div class="modal-content">
            <h1>Happy Birthday! üéâ</h1>
            <p>Welcome to your personal art gallery! I've created this virtual space to celebrate your special day with beautiful memories.</p>
            <button id="start-btn">Enter Gallery</button>
        </div>
    </div>

    <div id="controls-tutorial">
        <div class="tutorial-content">
            <h2 style="color: var(--accent); margin-bottom: 30px;">How to Explore</h2>
            
            <div class="control-item">
                <div class="control-icon">üéÆ</div>
                <div class="control-text">
                    <h3>Move & Look</h3>
                    <p>Left side: Joystick to walk.<br>Right side: Drag to look around.</p>
                </div>
            </div>
            
            <div class="control-item">
                <div class="control-icon">üîç</div>
                <div class="control-text">
                    <h3>Inspect Art</h3>
                    <p>Tap/Click any painting to glide closer for a better view.</p>
                </div>
            </div>
            
            <div class="control-item">
                <div class="control-icon">üö∂</div>
                <div class="control-text">
                    <h3>Resume Walking</h3>
                    <p>Move the joystick or click the floor to stop focusing on a painting.</p>
                </div>
            </div>
            
            <button id="tutorial-continue" style="margin-top: 30px; width: 100%;">Got it!</button>
        </div>
    </div>

    <div id="joystick-container">
        <div id="joystick-knob"></div>
    </div>

    <div id="look-touch-area"></div>

    <div class="instructions">Drag Left to Move ‚Ä¢ Drag Right to Look ‚Ä¢ Tap Art to Zoom</div>
    
    <div id="perf-monitor">FPS: 60</div>

    <audio id="bg-music" loop>
        <source src="https://www.chosic.com/wp-content/uploads/2021/04/Lofi-Study-Music.mp3" type="audio/mpeg">
    </audio>

    <div id="canvas-container"></div>

    <script>
        /**
         * CONFIGURATION
         */
        const CONFIG = {
            csvUrl: 'PASTE_YOUR_GOOGLE_SHEET_CSV_URL_HERE', 
            moveSpeed: 0.12,
            lookSensitivity: 0.003,
            roomSize: 22,
            roomLength: 32,
            numRooms: 3,
            paintingSize: 3.5,
            proximityDistance: 6,
            wallHeight: 9,
            spotLightIntensity: 0.8,
            ambientLightIntensity: 0.4
        };

        // Fallback images
        const FALLBACK_IMAGES = Array.from({length: 45}, (_, i) => `https://picsum.photos/id/${10 + i}/800/800`);

        let scene, camera, renderer, clock;
        let paintings = [];
        let moveState = { forward: 0, right: 0 };
        let lookState = { lat: 0, lon: 0 };
        let joystickActive = false;
        let isLooking = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let fps = 60;
        let frameCount = 0;
        let lastTime = performance.now();

        // Pre-load textures
        const textureLoader = new THREE.TextureLoader();
        const textureCache = new Map();

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.FogExp2(0x050505, 0.02); // Lighter fog for better visibility

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.7, 10);

            renderer = new THREE.WebGLRenderer({ 
            antialias: false, // Turn off for massive FPS boost on mobile
            powerPreference: "high-performance",
            precision: "mediump" // Lowers shader complexity for speed
            });
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 1 : 1); // Force lower pixel density for speed
            renderer.shadowMap.enabled = false; // Disable shadows entirely

            clock = new THREE.Clock();

            // Optimized lighting setup
            setupGalleryLighting();

            // Create beautiful gallery architecture
            createGalleryArchitecture();

            // Pre-load images
            const imageUrls = await fetchImageUrls();
            
            // Setup paintings with loading
            setupPaintings(imageUrls);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            setupControls();

            // Show birthday message
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loader').style.display = 'none';
                document.getElementById('birthday-modal').style.display = 'flex';
            }, 1000);

            animate();
        }

        async function fetchImageUrls() {
            try {
                if (CONFIG.csvUrl.includes('PASTE_YOUR')) throw new Error('Default');
                const response = await fetch(CONFIG.csvUrl);
                const data = await response.text();
                return data.split('\n').map(row => row.trim()).filter(url => url.startsWith('http'));
            } catch (e) {
                return FALLBACK_IMAGES;
            }
        }

        function setupGalleryLighting() {
            // Ambient light for overall illumination
            const ambient = new THREE.AmbientLight(0xffffff, CONFIG.ambientLightIntensity);
            scene.add(ambient);

            // Directional light for soft shadows
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = false; // Disable shadows for performance
            scene.add(directionalLight);

            // Spotlights for each room (for gallery effect)
            for(let i = 0; i < CONFIG.numRooms; i++) {
                // Center spotlight
                const spotLight = new THREE.SpotLight(0xffeedd, CONFIG.spotLightIntensity, 30, Math.PI/6, 0.5, 1);
                spotLight.position.set(0, 6, -i * CONFIG.roomLength - (CONFIG.roomLength / 2));
                spotLight.target.position.set(0, 0, -i * CONFIG.roomLength - (CONFIG.roomLength / 2));
                scene.add(spotLight);
                scene.add(spotLight.target);

                // Wall wash lights
                const leftWallLight = new THREE.PointLight(0xffeedd, 0.4, 15);
                leftWallLight.position.set(-CONFIG.roomSize/2 + 1, 4, -i * CONFIG.roomLength - (CONFIG.roomLength / 2));
                scene.add(leftWallLight);

                const rightWallLight = new THREE.PointLight(0xffeedd, 0.4, 15);
                rightWallLight.position.set(CONFIG.roomSize/2 - 1, 4, -i * CONFIG.roomLength - (CONFIG.roomLength / 2));
                scene.add(rightWallLight);
            }
        }

        function createGalleryArchitecture() {
            // Optimization: Use a single material for all walls to reduce draw calls
            const wallMat = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5f5, 
                roughness: 0.8, 
                metalness: 0.0 
            });
            
            const totalLength = CONFIG.numRooms * CONFIG.roomLength;
            const roomW = CONFIG.roomSize;
            const roomH = CONFIG.wallHeight;

            // 1. ENCLOSURE (Floor, Ceiling, Side Walls)
            // Floor
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomW, totalLength + 20), 
                new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2 }));
            floor.rotation.x = -Math.PI / 2;
            floor.position.z = -totalLength / 2 + 5;
            scene.add(floor);

            // Ceiling (Solid, no black void)
            const ceil = new THREE.Mesh(new THREE.PlaneGeometry(roomW, totalLength + 20), 
                new THREE.MeshStandardMaterial({ color: 0x111111 }));
            ceil.rotation.x = Math.PI / 2;
            ceil.position.y = roomH;
            ceil.position.z = floor.position.z;
            scene.add(ceil);

            // Continuous Side Walls (Prevents flickering gaps)
            const sideWallGeo = new THREE.PlaneGeometry(totalLength + 20, roomH);
            const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
            leftWall.position.set(-roomW/2, roomH/2, floor.position.z);
            leftWall.rotation.y = Math.PI / 2;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
            rightWall.position.set(roomW/2, roomH/2, floor.position.z);
            rightWall.rotation.y = -Math.PI / 2;
            scene.add(rightWall);

            // End Walls
            const endWallGeo = new THREE.PlaneGeometry(roomW, roomH);
            const backWall = new THREE.Mesh(endWallGeo, wallMat);
            backWall.position.set(0, roomH/2, -totalLength);
            scene.add(backWall);

            const frontWall = new THREE.Mesh(endWallGeo, wallMat);
            frontWall.position.set(0, roomH/2, 10);
            frontWall.rotation.y = Math.PI;
            scene.add(frontWall);
        }

        function createArchway(zPosition, trimMat) {
            const archWidth = 6;
            
            // Arch columns
            const columnGeo = new THREE.CylinderGeometry(0.3, 0.3, CONFIG.wallHeight - 2, 8);
            const leftColumn = new THREE.Mesh(columnGeo, trimMat);
            leftColumn.position.set(-archWidth/2, (CONFIG.wallHeight - 2)/2, zPosition);
            scene.add(leftColumn);

            const rightColumn = new THREE.Mesh(columnGeo, trimMat);
            rightColumn.position.set(archWidth/2, (CONFIG.wallHeight - 2)/2, zPosition);
            scene.add(rightColumn);

            // Arch top
            const archTopGeo = new THREE.BoxGeometry(archWidth, 0.5, 0.5);
            const archTop = new THREE.Mesh(archTopGeo, trimMat);
            archTop.position.set(0, CONFIG.wallHeight - 1.5, zPosition);
            scene.add(archTop);
        }

        function addWallDecorations() {
            const decorationMat = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                roughness: 0.6,
                metalness: 0.2
            });

            // Add simple decorative elements to walls
            for(let i = 0; i < CONFIG.numRooms; i++) {
                const zBase = -i * CONFIG.roomLength;
                
                // Add wall sconces or simple decorations
                for(let j = 0; j < 4; j++) {
                    const decoration = new THREE.BoxGeometry(0.5, 0.5, 0.1);
                    const leftDeco = new THREE.Mesh(decoration, decorationMat);
                    leftDeco.position.set(-CONFIG.roomSize/2 + 0.3, 5, zBase - (j+1) * (CONFIG.roomLength/5));
                    leftDeco.rotation.y = Math.PI/2;
                    scene.add(leftDeco);

                    const rightDeco = new THREE.Mesh(decoration, decorationMat);
                    rightDeco.position.set(CONFIG.roomSize/2 - 0.3, 5, zBase - (j+1) * (CONFIG.roomLength/5));
                    rightDeco.rotation.y = -Math.PI/2;
                    scene.add(rightDeco);
                }
            }
        }

        function setupPaintings(urls) {
            const imgsPerRoom = 15;
            let loadedCount = 0;
            const totalPaintings = Math.min(urls.length, imgsPerRoom * CONFIG.numRooms);

            urls.slice(0, totalPaintings).forEach((url, index) => {
                const roomIdx = Math.floor(index / imgsPerRoom);
                const localIdx = index % imgsPerRoom;
                const zBase = -roomIdx * CONFIG.roomLength;
                
                let x, z, rot;

                // Calculate positions (similar layout but with gallery spacing)
                if (localIdx < 6) { 
                    // Left Wall - evenly spaced
                    x = -CONFIG.roomSize / 2 + 0.1;
                    z = zBase - ((localIdx + 1.5) * (CONFIG.roomLength / 7.5));
                    rot = Math.PI / 2;
                } else if (localIdx < 12) { 
                    // Right Wall - evenly spaced
                    x = CONFIG.roomSize / 2 - 0.1;
                    z = zBase - ((localIdx - 5.5) * (CONFIG.roomLength / 7.5));
                    rot = -Math.PI / 2;
                } else { 
                    // Back walls - centered with gap for archway
                    const posInRow = localIdx - 12;
                    const positions = [-6, 0, 6]; // Leave center empty for archway
                    if (posInRow < positions.length) {
                        x = positions[posInRow];
                        z = zBase - CONFIG.roomLength + 0.1;
                        rot = 0;
                    } else {
                        return; // Skip if more than 3 back paintings
                    }
                }

                // Load texture with cache
                if (!textureCache.has(url)) {
                    textureLoader.load(url, (texture) => {
                        texture.encoding = THREE.sRGBEncoding;
                        texture.minFilter = THREE.LinearFilter; // Better performance
                        textureCache.set(url, texture);
                        createPainting(texture, x, z, rot, index);
                        loadedCount++;
                    }, undefined, (error) => {
                        console.error('Failed to load texture:', url, error);
                        loadedCount++;
                    });
                } else {
                    createPainting(textureCache.get(url), x, z, rot, index);
                    loadedCount++;
                }
            });
        }

        function createPainting(texture, x, z, rot, index) {
            const aspect = texture.image ? texture.image.width / texture.image.height : 1;
            const h = CONFIG.paintingSize;
            const w = h * aspect;

            // Create elegant frame
            const frameDepth = 0.15;
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.3, h + 0.3, frameDepth),
                new THREE.MeshStandardMaterial({ 
                    color: 0x222222,
                    roughness: 0.4,
                    metalness: 0.3
                })
            );

            // Create canvas with image
            const canvas = new THREE.Mesh(
                new THREE.PlaneGeometry(w * 0.95, h * 0.95),
                new THREE.MeshBasicMaterial({ 
                    map: texture,
                    toneMapped: false // Keep colors vibrant
                })
            );
            canvas.position.z = frameDepth / 2 + 0.01;
            frame.add(canvas);

            // Add subtle mat around painting
            const mat = new THREE.Mesh(
                new THREE.PlaneGeometry(w + 0.1, h + 0.1),
                new THREE.MeshStandardMaterial({ 
                    color: 0x111111,
                    roughness: 0.8
                })
            );
            mat.position.z = frameDepth / 2 + 0.005;
            frame.add(mat);

            frame.position.set(x, 4, z);
            frame.rotation.y = rot;
            frame.userData = { 
                targetScale: 1,
                originalPosition: frame.position.clone(),
                hoverOffset: 0
            };
            
            scene.add(frame);
            paintings.push(frame);
        }

        function setupControls() {
            const startBtn = document.getElementById('start-btn');
            const tutorialContinueBtn = document.getElementById('tutorial-continue');
            const joyContainer = document.getElementById('joystick-container');
            const joyKnob = document.getElementById('joystick-knob');
            const lookTouchArea = document.getElementById('look-touch-area');
            const music = document.getElementById('bg-music');

            startBtn.addEventListener('click', () => {
                document.getElementById('birthday-modal').style.display = 'none';
                document.getElementById('controls-tutorial').style.display = 'flex';
            });

            tutorialContinueBtn.addEventListener('click', () => {
                document.getElementById('controls-tutorial').style.display = 'none';
                joyContainer.style.display = 'block';
                lookTouchArea.style.display = 'block';
                if (music.paused) {
                    music.play().catch(e => console.log('Autoplay prevented:', e));
                }
                confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
            });

            // Joystick for movement
            joyContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
            });

            joyContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!joystickActive) return;
                
                const touch = e.touches[0];
                const rect = joyContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const dx = touch.clientX - centerX;
                const dy = touch.clientY - centerY;
                const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
                
                joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                
                // Simple intuitive controls
                moveState.forward = -Math.min(dy, 40) / 40;
                moveState.right = Math.min(dx, 40) / 40;
            });

            joyContainer.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystickActive = false;
                moveState.forward = 0; 
                moveState.right = 0;
                joyKnob.style.transform = `translate(-50%, -50%)`;
            });

            // Look controls
            lookTouchArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isLooking = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            });

            lookTouchArea.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isLooking || !e.touches[0]) return;
                
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;
                
                lookState.lon += deltaX * 0.5;
                lookState.lat += deltaY * 0.5;
                
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            });

            lookTouchArea.addEventListener('touchend', (e) => {
                e.preventDefault();
                isLooking = false;
            });

            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                if (e.key === 'w' || e.key === 'ArrowUp') moveState.forward = 1;
                if (e.key === 's' || e.key === 'ArrowDown') moveState.forward = -1;
                if (e.key === 'a' || e.key === 'ArrowLeft') moveState.right = -1;
                if (e.key === 'd' || e.key === 'ArrowRight') moveState.right = 1;
                
                // Space to jump (optional)
                if (e.key === ' ' && camera.position.y <= 1.8) {
                    camera.position.y += 0.5;
                    setTimeout(() => {
                        camera.position.y = 1.7;
                    }, 200);
                }
            });
            
            window.addEventListener('keyup', (e) => {
                if (['w','s','ArrowUp','ArrowDown'].includes(e.key)) moveState.forward = 0;
                if (['a','d','ArrowLeft','ArrowRight'].includes(e.key)) moveState.right = 0;
            });

            // Mouse look
            window.addEventListener('mousemove', (e) => {
                if (document.getElementById('controls-tutorial').style.display === 'none' && 
                    document.getElementById('birthday-modal').style.display === 'none' && 
                    e.buttons === 1) {
                    lookState.lon += e.movementX * 0.1;
                    lookState.lat += e.movementY * 0.1;
                }
            });

            // Prevent context menu on long press
            window.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Raycaster for clicking paintings
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            function onSelect(event) {
                // Don't trigger zoom if the user is touching the joystick
                if (joystickActive) return;

                const clientX = event.touches ? event.touches[0].clientX : event.clientX;
                const clientY = event.touches ? event.touches[0].clientY : event.clientY;

                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(paintings, true);

                if (intersects.length > 0) {
                    let obj = intersects[0].object;
                    // Traverse up to find the frame group
                    while(obj.parent && !paintings.includes(obj)) {
                        obj = obj.parent;
                    }
                    focusedPainting = obj;
                    
                    // Add a little celebratory "pop" sound or haptic feedback here if desired!
                } else {
                    focusedPainting = null;
                }
            }

            // Add listeners to the look area and window
            lookTouchArea.addEventListener('click', onSelect);
            window.addEventListener('mousedown', (e) => { if(e.button === 0) onSelect(e); });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('perf-monitor').textContent = `FPS: ${fps}`;
            }
        }

        let focusedPainting = null;

        // CONFIG Updates
        CONFIG.moveSpeed = 0.25; // Faster walk
        CONFIG.lookSensitivity = 0.3; // Slower, smoother look

        function animate() {
            requestAnimationFrame(animate);
            
            // Smooth Camera Rotation (Slightly dampened for low-end devices)
            lookState.lat = Math.max(-85, Math.min(85, lookState.lat));
            const phi = THREE.MathUtils.degToRad(90 - lookState.lat);
            const theta = THREE.MathUtils.degToRad(lookState.lon);

            const target = new THREE.Vector3();
            target.setFromSphericalCoords(1, phi, theta).add(camera.position);
            camera.lookAt(target);

            if (moveState.forward !== 0 || moveState.right !== 0) {
                focusedPainting = null; // Break focus if moving
                
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                const rightVec = new THREE.Vector3().crossVectors(camera.up, direction);

                // Movement
                camera.position.addScaledVector(direction, moveState.forward * CONFIG.moveSpeed);
                camera.position.addScaledVector(rightVec, -moveState.right * CONFIG.moveSpeed);

                // 3. COLLISION SYSTEM (Unable to walk through walls)
                const padding = 1.2; // Distance to keep from walls
                const xLimit = (CONFIG.roomSize / 2) - padding;
                const zLimitMax = 10 - padding;
                const zLimitMin = -(CONFIG.numRooms * CONFIG.roomLength) + padding;

                if (camera.position.x > xLimit) camera.position.x = xLimit;
                if (camera.position.x < -xLimit) camera.position.x = -xLimit;
                if (camera.position.z > zLimitMax) camera.position.z = zLimitMax;
                if (camera.position.z < zLimitMin) camera.position.z = zLimitMin;
            }
            
            // Performance: Only update what's visible
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>